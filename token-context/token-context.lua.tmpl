-- token-context/token-context.lua.tmpl
-- Este arquivo será preenchido dinamicamente pelo script shell.

-- Array de usuários com seus tokens e IDs
local users = {
    -- USERS_PLACEHOLDER
    -- Exemplo: { id = "user_uuid_1", token = "token-user-1" },
    --          { id = "user_uuid_2", token = "token-user-2" },
}

-- Verifica se há usuários configurados
if #users == 0 then
    io.stderr:write("ERRO: Nenhum usuário configurado no script Lua. Verifique o .env e o script de execução.\n")
    os.exit(1)
end

-- Carrega a biblioteca cjson para parsing JSON
local cjson = require("cjson")

-- Contador global para iterar sobre os usuários de forma cíclica
local user_idx_counter = 0

function request()
    user_idx_counter = user_idx_counter + 1
    local current_user_index = ((user_idx_counter - 1) % #users) + 1
    local current_user = users[current_user_index]

    local expected_token = current_user.token
    local expected_user_id = current_user.id

    -- Armazenar o token e userId esperados para validação na resposta
    -- Usamos o thread ID do wrk para associar o contexto à requisição.
    -- Como vamos usar -t 1, wrk.thread.id será sempre 1.
    wrk.expected = wrk.expected or {}
    wrk.expected[wrk.thread.id] = { token = expected_token, userId = expected_user_id }

    local headers = {
        ["Authorization"] = "Bearer " .. expected_token,
        ["X-User-Id"] = tostring(expected_user_id) -- Envia o User-ID também para depuração no backend
    }
    wrk.headers = headers
    return wrk.format("GET", wrk.url) -- wrk.url é a URL passada para o wrk
end

function response(status, headers, body)
    if status ~= 200 then
        io.stderr:write("ERRO: Status inesperado: " .. status .. " para requisição com token " .. (wrk.expected[wrk.thread.id] and wrk.expected[wrk.thread.id].token or "N/A") .. "\n")
        wrk.errors = wrk.errors + 1
        return
    end

    local success, parsed_data = pcall(cjson.decode, body)
    if not success then
        io.stderr:write("ERRO: Falha ao parsear JSON da resposta: " .. parsed_data .. ". Body: " .. body .. "\n")
        wrk.errors = wrk.errors + 1
        return
    end

    -- Verifica se 'data' existe e se 'token' e 'userId' estão dentro
    local received_token = parsed_data.data and parsed_data.data.token
    local received_user_id = parsed_data.data and parsed_data.data.userId

    if not received_token or not received_user_id then
        io.stderr:write("ERRO: Resposta da API não contém 'token' ou 'userId' esperado no campo 'data'. Body: " .. body .. "\n")
        wrk.errors = wrk.errors + 1
        return
    end

    local expected_data = wrk.expected[wrk.thread.id]
    local expected_token = expected_data.token
    local expected_user_id = expected_data.userId

    local token_match = (received_token == expected_token)
    -- Converte para string para comparação consistente, pois user_id pode vir como número e UUID como string
    local user_id_match = (tostring(received_user_id) == tostring(expected_user_id))

    if not token_match then
        io.stderr:write("ALERTA DE SEGURANÇA: Vazamento de Token detectado!\n")
        io.stderr:write("  Token Esperado: " .. expected_token .. "\n")
        io.stderr:write("  Token Recebido: " .. received_token .. "\n")
        io.stderr:write("  User ID Esperado (para este token): " .. expected_user_id .. "\n")
        io.stderr:write("  User ID Recebido (com este token): " .. received_user_id .. "\n")
        wrk.errors = wrk.errors + 1
    end

    if not user_id_match then
        io.stderr:write("ALERTA DE SEGURANÇA: User ID inconsistente detectado!\n")
        io.stderr:write("  Token Associado (recebido): " .. received_token .. "\n")
        io.stderr:write("  User ID Esperado: " .. expected_user_id .. "\n")
        io.stderr:write("  User ID Recebido: " .. received_user_id .. "\n")
        wrk.errors = wrk.errors + 1
    end

    -- Limpa o contexto para a próxima requisição
    wrk.expected[wrk.thread.id] = nil
end

function done(summary, latency, requests)
    io.write("\n-------------------------------------\n")
    io.write("Resultados do Teste de Isolamento de Autenticação:\n")
    io.write("Total de Requisições: " .. summary.requests .. "\n")
    io.write("Latência Média (p50): " .. summary.latency.p50 .. "\n")
    io.write("Latência 90 Percentil (p90): " .. summary.latency.p90 .. "\n")
    io.write("Requisições/segundo (taxa): " .. string.format("%.2f", summary.requests / summary.duration) .. "\n")
    io.write("Erros HTTP (ex: 404, 500): " .. summary.errors .. "\n")
    io.write("Erros de Validação (vazamento ou inconsistência): " .. (wrk.errors or 0) .. "\n") -- wrk.errors é nosso contador customizado

    if (wrk.errors or 0) > 0 then
        io.write("=========================================================\n")
        io.write("ATENÇÃO: FORAM DETECTADOS ERROS DE VALIDAÇÃO OU POSSÍVEIS VAZAMENTOS DE TOKEN OU USER ID!\n")
        io.write("Revise os logs acima para detalhes. (Saída stderr)\n")
        io.write("=========================================================\n")
    else
        io.write("Parabéns! Nenhum vazamento de token ou User ID inconsistente detectado.\n")
    end
    io.write("-------------------------------------\n")
end